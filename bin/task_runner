#!/usr/bin/env perl

# FIXME: Use the queue _id in the task to get the plugin name. Gotcha: WorkerThread has mongo setup, but wants the plugin name.
#        $workerthread->queues->find_one({_id => $doc->{queue}})->{constructor}

use 5.12.0;
use warnings;

use lib 'lib';	# FIXME: this is only needed for dev

use Cpanel::JSON::XS;
use Data::Dumper;
use Disbatch;
use Getopt::Long;
use MongoDB::OID 1.0.0;
use Try::Tiny::Retry;
use Safe::Isa;

my ($task_id, $plugin, $gfs, $config_file);

GetOptions(
    'task=s'     => \$task_id,
    'plugin=s'   => \$plugin,
    'gfs!'       => \$gfs,
    'config=s'   => \$config_file,
);

$gfs //= 1;	# use GridFS by default

my $json = Cpanel::JSON::XS->new->utf8->convert_blessed;

my $disbatch = Disbatch->new(class => $plugin, config_file => $config_file);
$disbatch->load_config;

my $logger = $disbatch->logger;

$logger->info("Starting task $task_id");

$logger->logdie('Config file must be passed with --config option') unless defined $config_file;

$logger->logdie('No --task') unless defined $task_id;
$logger->logdie('No --plugin') unless defined $plugin;
$logger->logdie("--plugin value '$plugin' must be a valid perl package name, matching /^[\\w:]+\$/") unless $plugin =~ /^[\w:]+$/;
$logger->logdie("$plugin not found for task $task_id") unless eval "use $plugin; 1";

my $oid = try { MongoDB::OID->new(value => $task_id) } catch { $logger->logdie($_) };
my $doc = retry {
    $disbatch->tasks->find_one_and_update({_id => $oid, status => -1, node => $disbatch->{node}}, {'$set' => {status => 0}});
} catch {
    $logger->logdie("Could not find and set task $task_id to status 0: $_");
};

$logger->logdie("No task found for $task_id") unless defined $doc;
$logger->info("parameters for $task_id: ", $json->encode($doc->{parameters}));

my $task = try {
    $plugin->new({id => $doc->{queue}}, $doc->{parameters});
} catch {
    $logger->logdie($_);
};
$task->{workerthread} = $disbatch;
$task->{id} = $oid;

my ($result) = try {
    $task->run;
} catch {
    $logger->error("Thread has uncaught exception: $_");
    {status => 2, stdout => 'Unable to complete', stderr => "Thread has uncaught exception: $_"};
};

my $status = $result->{status} == 1 ? 'succeeded' : 'failed';
$logger->info("Task $task_id $status.");
warn "STDOUT: $result->{stdout}";
warn "STDERR: $result->{stderr}";

# set status first:
retry { $disbatch->tasks->update_one({_id => $oid, status => 0, node => $disbatch->{node}}, {'$set' => {status => $result->{status}}}) }
catch { $logger->logdie("Could not update task $task_id status to $result->{status} after completion: $_") };

# decrement count_todo
try { $disbatch->queues->update_one({_id => $doc->{queue}}, {'$inc' => {count_todo => -1}}) } catch { $logger->error("Could not decrement count_todo for queue $doc->{queue}: $_") };

# set rest of result:
if ($gfs) {
    my $stdout_doc = retry { $disbatch->put_gfs($result->{stdout}, 'stdout', { task_id => $oid }) } retry_if { !/^MongoDB::DatabaseError: not authorized on / } catch { $logger->error("Could not create GridFS content for task $oid stdout: $_"); $result->{warning} = "$_"; undef; };
    my $stderr_doc = retry { $disbatch->put_gfs($result->{stderr}, 'stderr', { task_id => $oid }) } retry_if { !/^MongoDB::DatabaseError: not authorized on / } catch { $logger->error("Could not create GridFS content for task $oid stderr: $_"); $result->{warning} = "$_"; undef; };
    $result->{stdout} = $stdout_doc if defined $stdout_doc;
    $result->{stderr} = $stderr_doc if defined $stderr_doc;
    retry { $disbatch->tasks->update_one({_id => $oid, status => $result->{status}, node => $disbatch->{node}}, {'$set' => {stdout => $result->{stdout}, stderr => $result->{stderr}}}) }
    catch { $logger->logdie("Could not update task $task_id stdout/stderr file ids after completion: $_") };
} else {
    retry { $disbatch->tasks->update_one({_id => $oid, status => $result->{status}, node => $disbatch->{node}}, {'$set' => {stdout => $result->{stdout}, stderr => $result->{stderr}}}) }
    on_retry { $result->{stdout} = $_ if $_->$_isa('MongoDB::DocumentError') }	# MongoDB::DocumentError: Document exceeds maximum size 16777216
    catch { $logger->logdie("Could not update task $task_id stdout/stderr after completion: $_") };
}

__END__

=encoding utf8

=head1 NAME

task_runner - run a single Disbatch task

=head1 SYNOPSIS

  task_runner --plugin Disbatch::Plugin::Demo --task 565bc0d43fb6ecd1c8504492 --config etc/disbatch/config.json

=head1 ARGUMENTS

=over 2

=item --config <string>

Path to the JSON Disbatch config file.

=item --task <string>

The task's _id. Mandatory.

=item --plugin <string>

The name of the plugin (constructor) to use. Mandatory.

=item --nogfs

Do not use the custom GridFS implementation to store task stderr and stdout. Store them directly in the task like in previous versions.

While using GridFS can make analysing task output more complicated, we periodically have output that exceeds the maximum MongoDB document size.

If you are sure you won't need this, or can accept the loss of stdout and potentially stderr, you can disable this by adding C<"gfs": false> to the config file.

=back

=head1 SEE ALSO

L<Disbatch>

L<Disbatch::Web>

L<Disbatch::Roles>

L<Disbatch::Plugin::Demo>

L<disbatchd>

L<disbatch.pl>

L<disbatch-create-users>

=head1 AUTHORS

Ashley Willis <awillis@synacor.com>

=head1 COPYRIGHT AND LICENSE

This software is Copyright (c) 2016 by Ashley Willis.

This is free software, licensed under:

  The Apache License, Version 2.0, January 2004
